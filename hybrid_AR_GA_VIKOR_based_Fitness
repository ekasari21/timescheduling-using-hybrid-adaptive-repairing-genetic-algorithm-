import random
import pandas as pd
from openpyxl import Workbook
import matplotlib.pyplot as plt
import numpy as np

# Baca file Excel
file_excel='template_penjadwalan.xlsx'
indek_mk=['Kode','dosen1','dosen2','JenisRuang','Prodi','Semester']
sheet_nama='MataKuliah'
sesi = ["sesi1","sesi2","sesi3","sesi4","sesi5","sesi6"]
hari = ["senin","selasa","rabu","kamis","jumat"]
indek_ruangan=['KodeRuang']
sheet_ruang='Ruang'
indek_makul=['Kode']
# Baca file Excel
try:
    dt_mk = pd.read_excel(file_excel, sheet_name=sheet_nama, usecols=indek_mk)
    dt_ruang =pd.read_excel(file_excel, sheet_name=sheet_ruang, usecols=indek_ruangan)
except Exception as e:
    print(f"Gagal membaca file Excel: {e}")
    exit()

data_ruang = dt_ruang.iloc[:, 0].tolist() 
tuple_generator = dt_mk.itertuples(index=False, name=None)

# Konversi generator menjadi list of tuples
data_mk = list(tuple_generator)
makul = dt_mk['Kode'].tolist()

POP_SIZE =50
GENERATIONS = 250
BASE_MUTATION_RATE = 0.2
MUTATION_MIN = 0.01
MUTATION_MAX = 0.5
# ==== REPRESENTASI CHROMOSOME ====
# Setiap mata kuliah diwakili oleh (sesi, hari)
new_kromosom=[]

# --------------- Random Kromosom --------------------------------
def random_kromosom():
    for kode,dosen1, dosen2, jenisRuang,prodi,semester in data_mk:
        if jenisRuang == 1:
            ruang_baru = random.choice(data_ruang)  # ambil ruangan acak
            #acak=[(dosen1,dosen2,ruang_baru,prodi,semester,random.choice(sesi), random.choice(hari))]
            new_kromosom.append((kode,dosen1,dosen2,ruang_baru,prodi,semester,random.choice(sesi), random.choice(hari)))
        else:
            ruang_baru = jenisRuang  # biarkan apa adanya
            #acak=[(dosen1,dosen2,ruang_baru,prodi,semester,random.choice(sesi), random.choice(hari))] 
            new_kromosom.append((kode,dosen1,dosen2,ruang_baru,prodi,semester,random.choice(sesi), random.choice(hari)))
    return new_kromosom

#============================ Fungsi fitness sederhana (mengembalikan total penalty + daftar bentrok)
def fitness_with_conflict(individu):
    penalty = 0
    seen_dosen = {}
    seen_ruang = {}
    conflict_indices = set()

    for idx, (kode, dosen1, dosen2, ruang, prodi, semester, sesi, hari) in enumerate(individu):
        key_dosen1 = (hari, sesi, dosen1)
        key_dosen2 = (hari, sesi, dosen2)
        key_ruang = (hari, sesi, ruang)

        # cek bentrok dosen1
        if key_dosen1 in seen_dosen:
            penalty += 5
            conflict_indices.add(idx)
            conflict_indices.add(seen_dosen[key_dosen1])
        else:
            seen_dosen[key_dosen1] = idx

        # cek bentrok dosen2
        if dosen1 != dosen2:
            if key_dosen2 in seen_dosen:
                penalty += 5
                conflict_indices.add(idx)
                conflict_indices.add(seen_dosen[key_dosen2])
            else:
                seen_dosen[key_dosen2] = idx

        # cek bentrok ruang
        if key_ruang in seen_ruang:
            penalty += 5
            conflict_indices.add(idx)
            conflict_indices.add(seen_ruang[key_ruang])
        else:
            seen_ruang[key_ruang] = idx

    return -penalty, list(conflict_indices)


#=====================Fungsi repair kromosom hanya gen bentrok
def repair_chromosome(individu, max_iter):
    best = individu[:]
    best_fit, conflicts = fitness_with_conflict(best)
    iter_count = 0

    while best_fit < 0 and iter_count < max_iter and conflicts:
        iter_count += 1
        for idx in conflicts:
            kode, dosen1, dosen2, ruang, prodi, semester, new_sesi, new_hari = best[idx]
            # ganti sesi dan hari acak
            best[idx] = (kode, dosen1, dosen2, ruang, prodi, semester, random.choice(sesi), random.choice(hari))

        best_fit, conflicts = fitness_with_conflict(best)
        
    return best

# --------------- Menghitung konflik dosen
def hitung_conflict_dosen(chrom):
    seen = {}
    conflict = 0
    for mk in chrom:
        kode, dosen1, dosen2, ruang, prodi, semester, sesi, hari = mk
        key = (hari, sesi)
        if key not in seen:
            seen[key] = []
        if dosen1 in seen[key] or dosen2 in seen[key]:
            conflict += 1
        seen[key].extend([dosen1, dosen2])
    return conflict

# --------------- Menghitung konflik Ruang
def hitung_conflict_ruang(chrom):
    seen = {}
    conflict = 0
    for mk in chrom:
        _, _, _, ruang, _, _, sesi, hari = mk
        key = (ruang,hari, sesi)
        if key not in seen:
            seen[key] = []
        if ruang in seen[key]:
            conflict += 1
        seen[key].append(ruang)
    return conflict

# --------------- Menghitung konflik Hari
def hitung_conflict_hari(chrom):
    # Misal makin banyak hari kosong → lebih buruk
    hari_set = set([mk[7] for mk in chrom])
    return abs(len(hari_set) - 5)

# --------------- Menghitung konflik sesi
def hitung_conflict_sesi(chrom):
    # Makin tidak merata sesi → lebih buruk
    from collections import Counter
    count = Counter([mk[6] for mk in chrom])
    return max(count.values()) - min(count.values())

# ---- Perhitungan Fitness dengan VIKOR
def func_fitness_vikor(populasi, w=[0.4, 0.3, 0.3], v=0.5):
    # ---- 1. Hitung nilai konflik untuk setiap kromosom
    matrix = []
    for chrom in populasi:
        dosen_conflict = hitung_conflict_dosen(chrom)
        ruang_conflict  = hitung_conflict_ruang(chrom)
        sesi_conflict   = hitung_conflict_sesi(chrom)
        matrix.append([dosen_conflict, ruang_conflict, sesi_conflict])

    matrix = np.array(matrix, dtype=float)
    m, n = matrix.shape

    # ---- 2. Tangani kasus nilai identik (tanpa variasi)
    if np.all(matrix == matrix[0]):
        # Jika semua individu identik → tambahkan noise kecil agar tetap bisa dibandingkan
        matrix = matrix + np.random.uniform(1e-6, 1e-5, size=matrix.shape)

    # ---- 3. Tentukan nilai terbaik (f*) dan terburuk (f-) untuk tiap kriteria
    f_best = np.min(matrix, axis=0)   # minimisasi
    f_worst = np.max(matrix, axis=0)

    # ---- 4. Normalisasi nilai kriteria
    range_f = f_worst - f_best
    range_f[range_f == 0] = 1e-6      # hindari pembagian nol

    S = np.zeros(m)
    R = np.zeros(m)

    for i in range(m):
        diff = w * (matrix[i] - f_best) / range_f
        S[i] = np.sum(diff)
        R[i] = np.max(diff)

    # ---- 5. Hitung Q_i (nilai kompromi VIKOR)
    S_best, S_worst = np.min(S), np.max(S)
    R_best, R_worst = np.min(R), np.max(R)

    # Hindari pembagian nol
    den_S = S_worst - S_best
    den_R = R_worst - R_best
    if den_S == 0: den_S = 1e-6
    if den_R == 0: den_R = 1e-6

    Q = v * ((S - S_best) / den_S) + (1 - v) * ((R - R_best) / den_R)

    # ---- 6. Tambahan: jika semua Q == 0, tambahkan variasi kecil
    if np.all(Q == 0):
        Q = Q + np.random.uniform(1e-4, 1e-3, size=Q.shape)

    # ---- 7. Kembalikan fitness (semakin kecil semakin baik)
    return Q.tolist()

#========  function valid
def is_valid(chrom):
    """
    Contoh validasi sederhana: 
    Tidak boleh ada (ruang, sesi, hari) yang sama untuk dua matakuliah berbeda.
    """
    seen = set()
    for gen in chrom:
        _, _, _, ruang, _, _, sesi, hari = gen
        key = (ruang, sesi, hari)
        if key in seen:
            return False
        seen.add(key)
    return True

#==================Repairing Kromosom
def repair(chrom):
    """
    Fungsi repair sederhana:
    Jika duplikat (ruang, sesi, hari), ganti sesi dan hari secara acak.
    """
    repaired = []
    seen = set()
    for gene in chrom:
        kode, d1, d2, ruang, prodi, sem, sesi, hari = gene
        key = (ruang, sesi, hari)
        while key in seen:  # ubah sampai unik
            sesi = random.choice(["sesi1", "sesi2", "sesi3", "sesi4", "sesi5", "sesi6"])
            hari = random.choice(["senin", "selasa", "rabu", "kamis", "jumat", "sabtu"])
            key = (ruang, sesi, hari)
        seen.add(key)
        repaired.append((kode, d1, d2, ruang, prodi, sem, sesi, hari))
    return repaired   

# ==== Adaptive Repairing Rank Selection ====
def selection(population):
    fitness_values = func_fitness_vikor(population)
    mean_fit = sum(fitness_values) / len(fitness_values)

    repaired_pop = []
    repaired_fit = []

    for ind, fit in zip(population, fitness_values):
        # adaptif: hanya repair jika fitness lebih buruk dari rata-rata
        if fit > mean_fit or not is_valid(ind):
            ind = repair(ind)
            fit = func_fitness_vikor(ind)
        repaired_pop.append(ind)
        repaired_fit.append(fit)

    # ==== Rank Selection ====
    # Urutkan dari terbaik (fitness terkecil) ke terburuk
    ranked = sorted(zip(repaired_pop, repaired_fit), key=lambda x: x[1])
    ranks = list(range(1, len(ranked) + 1))
    total_rank = sum(ranks)

    # Probabilitas proporsional terhadap ranking (semakin tinggi rank → peluang lebih besar)
    probs = [r / total_rank for r in ranks]

    # Pilih individu berdasarkan probabilitas rank
    selected = random.choices(
        [ind for ind, _ in ranked],
        weights=probs,
        k=len(population)
    )

    best = ranked[0][0]  # individu terbaik
    best_fit = ranked[0][1]

    return selected

# ==== CROSSOVER using adaptive repairing ====
""" def crossover(p1, p2):
    point = random.randint(1, len(populasi)-1)
    return p1[:point] + p2[point:] """
def crossover(p1, p2):
    point = random.randint(1, len(p1) - 1)
    child = p1[:point] + p2[point:]

    # --- 1. Hitung konflik (ruang/sesi/hari sama untuk dosen yang sama) ---
    conflicts = []
    seen = {}
    for i, gen in enumerate(child):
        kode, dosen1, dosen2, ruang, prodi, sem, sesi, hari = gen
        key_dosen = (dosen1, sesi, hari)
        key_ruang = (ruang, sesi, hari)

        if key_dosen in seen or key_ruang in seen:
            conflicts.append(i)
        seen[key_dosen] = True
        seen[key_ruang] = True

    violation_rate = len(conflicts) / len(child)

    # --- 2. Tentukan tingkat repair adaptif ---
    if violation_rate > 0.3:
        repair_intensity = "high"
    elif violation_rate > 0.1:
        repair_intensity = "medium"
    else:
        repair_intensity = "low"

    # --- 3. Lakukan perbaikan adaptif ---
    for i in conflicts:
        kode, dosen1, dosen2, ruang, prodi, sem, ran_sesi, ran_hari = child[i]

        if repair_intensity == "high":
            # ubah ruang, sesi, dan hari
            if ruang[0] == "R":
                ruang = random.choice(data_ruang)
            else :
                ruang=ruang
            ran_sesi = random.choice(sesi)
            ran_hari = random.choice(hari)
        elif repair_intensity == "medium":
            # ubah salah satu dari sesi/hari
            ran_sesi = random.choice(sesi)
        else:
            # hanya ubah jika sangat perlu (mungkin ruang saja)
            if ruang[0] == "R":
                ruang = random.choice(data_ruang)
            else :
                ruang=ruang
        child[i] = (kode, dosen1, dosen2, ruang, prodi, sem, ran_sesi, ran_hari)

    return child

def cek_available_slot(jadwal, hari, sesi, ruang):
    for data in jadwal:
        kode, dosen1, dosen2, dt_ruang, prodi, semester, sesi_jadwal, hari_jadwal = data
        
        if hari_jadwal == hari and sesi_jadwal == sesi:
            if ruang == dt_ruang:
                return False  # ruang sudah terpakai di slot ini
    return True  # tidak ditemukan bentrok, berarti availabl

#==== proses Mutasi
def mutate(child, mutation_rate):
    """
    Mutasi satu kromosom (child) dengan hybrid adaptive repairing.
    child: list of gen (kode,dosen1,dosen2,ruangan,prodi,semester,sesi,hari)
    """
    new_child = []
  
    for gene in child:
        if random.random() < mutation_rate:
            kode, dosen1, dosen2, ruangan, prodi, semester, sesi, hari = gene
            
            # Mutasi ruang
            if ruangan[0] == "R":
                ruangan = random.choice(data_ruang)
            
            # Mutasi sesi dan hari
           
            rand_sesi = ["sesi1","sesi2","sesi3","sesi4","sesi5","sesi6"]
            rand_hari = ["senin","selasa","rabu","kamis","jumat","sabtu"]
            new_gene = (kode, dosen1, dosen2, ruangan, prodi, semester, random.choice(rand_sesi), random.choice(rand_hari))
            
            # Repair sederhana: cek tabrakan dengan gen lain di new_child
            for exist_gene in new_child:
                # Cek dosen
                if (dosen1 in exist_gene[1:3] or dosen2 in exist_gene[1:3]) and sesi == exist_gene[6] and hari == exist_gene[7]:
                    sesi = random.choice(sesi)
                    hari = random.choice(hari)
                    new_gene = (kode, dosen1, dosen2, ruangan, prodi, semester, sesi, hari)
                # Cek ruang
                if ruangan == exist_gene[3] and sesi == exist_gene[6] and hari == exist_gene[7]:
                    ruangan = random.choice(data_ruang)
                    new_gene = (kode, dosen1, dosen2, ruangan, prodi, semester, sesi, hari)
            
            new_child.append(new_gene)
        else:
            new_child.append(gene)
    return new_child
# === adaptive mutation rate
def adaptive_mutation_rate(prev_best, curr_best, base_rate):
    if curr_best < prev_best:
        # Jika ada perbaikan fitness → turunkan mutation rate (eksploitasi)
        return max(MUTATION_MIN, base_rate * 0.9)
    else:
        # Jika tidak membaik → naikkan mutation rate (eksplorasi)
        return min(MUTATION_MAX, base_rate * 1.1)
# --- Melakukan Inisialisasi acak kromosom

populasi = [random_kromosom() for _ in range(POP_SIZE)]


fit_best=[] #hasil fitness kromosom terbaik
mean_fit = []
mutation_rate = BASE_MUTATION_RATE
prev_best_fitness = float('inf')  # karena kita minimisasi

best_fitness_history = []
mean_fitness_history = []
mutation_rate = BASE_MUTATION_RATE
prev_best_fitness = float('inf')  # karena kita minimisasi
for gen in range(GENERATIONS):
    fitness_values = func_fitness_vikor(populasi)
    best_fit = min(fitness_values)
    mean_fit = sum(fitness_values) / len(fitness_values)
    best_fitness_history.append(best_fit)
    mean_fitness_history.append(mean_fit)

    new_population = []
    while len(new_population) < POP_SIZE:
        parent1, parent2 = random.sample(populasi, 2)
        child = crossover(parent1, parent2)
        child = mutate(child,mutation_rate)
        new_population.append(child)
         # Update mutation rate adaptif
        mutation_rate = adaptive_mutation_rate(prev_best_fitness, best_fit, mutation_rate)
        prev_best_fitness = best_fit
        if len(new_population) < POP_SIZE:
            child = mutate(child,mutation_rate)
            new_population.append(child)
    populasi = new_population

# ==========================================
# 9️⃣ Hasil Akhir
# ==========================================
fitness_values = func_fitness_vikor(populasi) 
best_index = fitness_values.index(min(fitness_values))
best_solution = populasi[best_index]

print("\n=== Jadwal Terbaik ===")
for j in best_solution:
    print(j)
  

# === setelah semua generasi selesai, tampilkan grafik ===
plt.figure(figsize=(8, 5))
plt.plot(best_fitness_history, label='Best Fitness')
plt.plot(mean_fitness_history, label='Mean Fitness')
plt.xlabel('Generasi')
plt.ylabel('Fitness')
plt.title('Pergerakan Nilai Fitness Selama Evolusi')
plt.legend()
plt.grid(True)
plt.show()
